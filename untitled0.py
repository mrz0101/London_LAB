# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VS-BBaDy8UWFUljymyyLG7tTrfvZnsEj
"""

import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import plotly.express as px
import plotly.graph_objects as go
import difflib
from plotly.subplots import make_subplots

# Set page configuration with custom theme and style
st.set_page_config(
    layout="wide",
    page_title="Consultant Matching Dashboard",
    page_icon="🧩",
    initial_sidebar_state="expanded"
)

# Apply custom CSS for a more professional look
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        font-weight: 700;
        color: #1E3A8A;
        margin-bottom: 0.5rem;
    }
    .sub-header {
        font-size: 1.5rem;
        font-weight: 600;
        color: #2563EB;
        margin-bottom: 1rem;
    }
    .card {
        background-color: #FFFFFF;
        border-radius: 0.5rem;
        padding: 1.5rem;
        box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
        margin-bottom: 1rem;
    }
    .metric-card {
        text-align: center;
        padding: 1rem;
        background-color: #F3F4F6;
        border-radius: 0.5rem;
        margin-bottom: 1rem;
    }
    .metric-value {
        font-size: 2rem;
        font-weight: 700;
        color: #1E3A8A;
    }
    .metric-label {
        font-size: 0.9rem;
        color: #4B5563;
    }
    .radar-chart {
        margin-top: 1rem;
        margin-bottom: 1.5rem;
    }
    .stExpander {
        border: none !important;
        box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
        border-radius: 0.5rem !important;
        margin-bottom: 0.5rem;
    }
</style>
""", unsafe_allow_html=True)

# Display header
st.markdown('<div class="main-header">🧩 Consultant-Project Matching Dashboard</div>', unsafe_allow_html=True)
st.markdown("_Intelligent resource allocation for optimal project outcomes_")

# --- Load Data ---
@st.cache_data
def load_data():
    try:
        employees = pd.read_csv("Employees_new.csv")
        projects = pd.read_csv("Projects_new.csv")
        allocations = pd.read_csv("Allocations.csv")
        pipeline = pd.read_csv("Pipeline.csv")
        return employees, projects, allocations, pipeline
    except Exception as e:
        st.error(f"Error loading data: {e}")
        return None, None, None, None

employees, projects, allocations, pipeline = load_data()

# Check if data loaded correctly
if employees is None or projects is None or allocations is None:
    st.error("Failed to load data files. Please check file paths and formats.")
    st.stop()

# --- Process Data ---
# Normalize Skills - Fixed to handle string format
def normalize_skills(skill_str):
    if isinstance(skill_str, str):
        return [s.strip().lower() for s in skill_str.split(';')]
    return []

# Process primary skills
employees['PrimarySkill'] = employees['PrimarySkill'].fillna("")
employees['PrimarySkill'] = employees['PrimarySkill'].astype(str).str.lower()

# Process secondary skills - Fixed to avoid pandas Series truth value error
employees['SecondarySkills'] = employees['SecondarySkills'].fillna("")
employees['SecondarySkills'] = employees['SecondarySkills'].astype(str).apply(normalize_skills)

# Extract skills from project descriptions
def extract_skills_from_description(desc):
    if pd.isna(desc) or not isinstance(desc, str):
        return ""

    # Simple extraction based on common technical terms
    common_skills = [
        "python", "java", "sql", "aws", "azure", "machine learning",
        "data science", "agile", "scrum", "devops", "cloud", "analytics",
        "project management", "ai", "javascript", "react", "angular", "node",
        "consulting", "strategy", "business analysis", "design", "ui/ux"
    ]

    desc_lower = desc.lower()
    found_skills = [skill for skill in common_skills if skill in desc_lower]
    return "; ".join(found_skills)

# Add extracted skills to projects - Handle missing fields
projects['ProjectDescription'] = projects['ProjectDescription'].fillna("")
projects['ExtractedSkills'] = projects['ProjectDescription'].apply(extract_skills_from_description)

# --- Availability Map ---
def build_availability_map(alloc_df, employees_df):
    today = datetime.now().date()
    future_months = 6  # Look ahead 6 months
    future_date = today + timedelta(days=future_months*30)

    # Initialize with all employees having 0% allocation
    emp_availability = {emp: {} for emp in employees_df['EmployeeID']}

    # Add current allocations
    for _, row in alloc_df.iterrows():
        emp_id = row['EmployeeID']

        # Handle date parsing errors
        try:
            start = pd.to_datetime(row['AllocationStart']).date()
            end = pd.to_datetime(row['AllocationEnd']).date()
        except (ValueError, pd.errors.ParserError):
            # Default to current month if date is invalid
            start = today
            end = today + timedelta(days=30)

        alloc = row['AllocationPercent']

        for date in pd.date_range(start, end):
            date = date.date()
            if date in emp_availability[emp_id]:
                emp_availability[emp_id][date] += alloc
            else:
                emp_availability[emp_id][date] = alloc

    # Calculate availability by time period
    availability_by_period = {}
    for emp_id in employees_df['EmployeeID']:
        # Calculate availability for next month, 3 months, and 6 months
        month_1 = today + timedelta(days=30)
        month_3 = today + timedelta(days=90)
        month_6 = today + timedelta(days=180)

        periods = {
            "1_month": [today, month_1],
            "3_months": [today, month_3],
            "6_months": [today, month_6]
        }

        availability_by_period[emp_id] = {}

        for period_name, [start, end] in periods.items():
            dates_in_period = [d.date() for d in pd.date_range(start, end)]
            allocations = [emp_availability[emp_id].get(date, 0) for date in dates_in_period]
            avg_allocation = np.mean(allocations) if allocations else 0
            availability_by_period[emp_id][period_name] = 100 - avg_allocation

    return emp_availability, availability_by_period

availability_map, availability_by_period = build_availability_map(allocations, employees)

# Add availability columns to employees dataframe
for period in ["1_month", "3_months", "6_months"]:
    employees[f'Available_{period}'] = employees['EmployeeID'].apply(
        lambda emp_id: availability_by_period.get(emp_id, {}).get(period, 100)
    )

# --- Enhanced Scoring Function ---
def score_employee(emp, project, weight_config=None):
    # Default weights
    if weight_config is None:
        weight_config = {
            "skills": 0.5,
            "availability": 0.25,
            "seniority": 0.15,
            "text_match": 0.1
        }

    scores = {}
    total_score = 0
    reasons = []

    # Get employee data - Fixed to handle data types properly
    primary = emp['PrimarySkill'].lower() if isinstance(emp['PrimarySkill'], str) else ""
    secondary = emp['SecondarySkills'] if isinstance(emp['SecondarySkills'], list) else []

    # Get project data - Fixed to handle missing data
    project_text = project.get('ProjectDescription', "")
    if pd.isna(project_text) or not isinstance(project_text, str):
        project_text = ""
    else:
        project_text = project_text.lower()

    project_extracted_skills = project.get('ExtractedSkills', "")
    if pd.isna(project_extracted_skills) or not isinstance(project_extracted_skills, str):
        project_extracted_skills = ""
    else:
        project_extracted_skills = project_extracted_skills.lower()

    # 1. Skill match (50%)
    skill_score = 0
    # Primary skill match (worth more)
    if primary and (primary in project_text or primary in project_extracted_skills):
        skill_score += 0.7
        reasons.append(f"✅ Primary skill ({primary}) matches project needs")

    # Secondary skills match
    matching_secondary = [skill for skill in secondary if skill in project_text or skill in project_extracted_skills]
    if matching_secondary:
        # More matching skills = higher score
        secondary_score = min(len(matching_secondary) * 0.15, 0.3)
        skill_score += secondary_score
        reasons.append(f"✅ Matching secondary skills: {', '.join(matching_secondary)}")

    # Normalize skill score to 0-1
    skill_score = min(skill_score, 1.0)
    scores["skills"] = skill_score
    total_score += weight_config["skills"] * skill_score

    if skill_score == 0:
        reasons.append("❌ No direct skill matches found")

    # 2. Availability (25%)
    # Handle date parsing safely
    try:
        start = pd.to_datetime(project.get('Start Date', datetime.now())).date()
    except (ValueError, pd.errors.ParserError):
        start = datetime.now().date()

    try:
        end = pd.to_datetime(project.get('End Date', start + timedelta(days=90))).date()
    except (ValueError, pd.errors.ParserError):
        end = start + timedelta(days=90)

    emp_id = emp['EmployeeID']

    # Calculate average availability over project duration
    dates_in_project = [d.date() for d in pd.date_range(start, end)]
    daily_alloc = [availability_map.get(emp_id, {}).get(date, 0) for date in dates_in_project]
    avg_allocation = np.mean(daily_alloc) if daily_alloc else 0
    available_capacity = 100 - avg_allocation

    # Convert to 0-1 scale with threshold for reasonableness
    availability_score = min(available_capacity / 50, 1.0)  # 50% availability is considered good
    scores["availability"] = availability_score
    total_score += weight_config["availability"] * availability_score

    if available_capacity >= 70:
        reasons.append(f"✅ High availability: {available_capacity:.1f}%")
    elif available_capacity >= 40:
        reasons.append(f"⚠️ Moderate availability: {available_capacity:.1f}%")
    else:
        reasons.append(f"❌ Low availability: {available_capacity:.1f}%")

    # 3. Seniority match (15%)
    seniority_level = emp.get('Seniority', "Junior")
    if pd.isna(seniority_level) or not isinstance(seniority_level, str):
        seniority_level = "Junior"

    project_risk = project.get('Risk Level', "Medium")
    if pd.isna(project_risk) or not isinstance(project_risk, str):
        project_risk = "Medium"

    # Map seniority to numeric value
    seniority_map = {
        "Junior": 1,
        "Associate": 2,
        "Mid": 3,
        "Senior": 4,
        "Principal": 5,
        "Director": 5
    }

    # Map risk level to required seniority
    risk_seniority_map = {
        "Low": 2,  # Associate level is fine
        "Medium": 3,  # Mid level recommended
        "High": 4   # Senior level recommended
    }

    emp_seniority_value = seniority_map.get(seniority_level, 2)
    required_seniority = risk_seniority_map.get(project_risk, 3)

    # Perfect match or overqualified
    if emp_seniority_value >= required_seniority:
        seniority_score = 1.0
        if emp_seniority_value > required_seniority:
            reasons.append(f"✅ Overqualified: {seniority_level} for {project_risk} risk project")
        else:
            reasons.append(f"✅ Perfect seniority match: {seniority_level} for {project_risk} risk project")
    else:
        # Underqualified, score based on gap
        seniority_score = 1.0 - min((required_seniority - emp_seniority_value) * 0.3, 0.9)
        reasons.append(f"⚠️ Underqualified: {seniority_level} for {project_risk} risk project")

    scores["seniority"] = seniority_score
    total_score += weight_config["seniority"] * seniority_score

    # 4. Text similarity for skill description (10%)
    emp_skill_summary = emp.get('SkillSummary', "")
    if pd.isna(emp_skill_summary) or not isinstance(emp_skill_summary, str):
        emp_skill_summary = ""

    if emp_skill_summary and project_text:
        # Use sequence matcher for more nuanced matching
        sim_ratio = difflib.SequenceMatcher(None, emp_skill_summary.lower(), project_text.lower()).ratio()
        text_score = sim_ratio
    else:
        text_score = 0

    scores["text_match"] = text_score
    total_score += weight_config["text_match"] * text_score

    if text_score > 0.3:
        reasons.append(f"✅ Strong skill description match: {text_score:.2f}")
    elif text_score > 0.1:
        reasons.append(f"⚠️ Partial skill description match: {text_score:.2f}")
    else:
        reasons.append("❌ Limited skill description overlap")

    # 5. Diversity bonus (not adding to total score yet, just flagging)
    diversity_group = emp.get('DiversityInclusionGroup', "")
    if diversity_group and not pd.isna(diversity_group) and isinstance(diversity_group, str):
        reasons.append(f"🌟 Diversity & Inclusion: {diversity_group}")
    else:
        diversity_group = ""

    # Round final score for presentation
    final_score = round(total_score * 100, 1)

    # Return detailed results
    return {
        "EmployeeID": emp['EmployeeID'],
        "Name": f"{emp.get('FirstName', '')} {emp.get('LastName', '')}",
        "Title": emp.get('Title', ''),
        "Seniority": seniority_level,
        "Location": emp.get('Location', ''),
        "MatchScore": final_score,
        "ComponentScores": scores,
        "AvailableCapacity": available_capacity,
        "SkillSummary": emp_skill_summary,
        "PrimarySkill": primary,
        "SecondarySkills": secondary,
        "Explanation": reasons,
        "DiversityGroup": diversity_group
    }

# --- Match Candidates for a Project ---
def match_candidates(project_id, top_n=10, weights=None):
    try:
        project_rows = projects[projects['Project ID'] == project_id]
        if project_rows.empty:
            st.error(f"Project ID {project_id} not found in projects data.")
            return [], {}

        project = project_rows.iloc[0].to_dict()
        scored = []

        for _, emp in employees.iterrows():
            score_details = score_employee(emp, project, weights)
            scored.append(score_details)

        sorted_candidates = sorted(scored, key=lambda x: -x['MatchScore'])[:top_n]
        return sorted_candidates, project
    except Exception as e:
        st.error(f"Error in match_candidates: {e}")
        return [], {}

# --- Create Radar Chart for Score Components ---
def create_radar_chart(candidate_scores):
    try:
        # Extract the score components
        categories = ['Skills', 'Availability', 'Seniority', 'Text Match']
        component_scores = candidate_scores.get("ComponentScores", {})
        scores = [
            component_scores.get("skills", 0) * 100,
            component_scores.get("availability", 0) * 100,
            component_scores.get("seniority", 0) * 100,
            component_scores.get("text_match", 0) * 100
        ]

        # Create the radar chart
        fig = go.Figure()

        fig.add_trace(go.Scatterpolar(
            r=scores,
            theta=categories,
            fill='toself',
            name='Match Components',
            line_color='#3B82F6'
        ))

        fig.update_layout(
            polar=dict(
                radialaxis=dict(
                    visible=True,
                    range=[0, 100]
                )
            ),
            showlegend=False,
            margin=dict(t=0, b=0, l=30, r=30),
            height=300
        )

        return fig
    except Exception as e:
        st.error(f"Error creating radar chart: {e}")
        return None

# --- Visualization Functions ---
def create_availability_chart(candidates):
    """Create a stacked bar chart showing availability by time periods"""
    if not candidates:
        return None

    try:
        avail_data = []
        for person in candidates:
            emp_id = person['EmployeeID']
            emp_rows = employees[employees['EmployeeID'] == emp_id]

            if emp_rows.empty:
                continue

            emp_data = emp_rows.iloc[0]

            avail_data.append({
                'Name': person['Name'],
                'Next Month': emp_data.get('Available_1_month', 0),
                '3 Months': emp_data.get('Available_3_months', 0),
                '6 Months': emp_data.get('Available_6_months', 0),
                'Match Score': person['MatchScore']
            })

        if not avail_data:
            return None

        df = pd.DataFrame(avail_data)

        # Melt the dataframe for better plotting
        df_melted = df.melt(
            id_vars=['Name', 'Match Score'],
            value_vars=['Next Month', '3 Months', '6 Months'],
            var_name='Time Period',
            value_name='Availability %'
        )

        # Create the chart
        fig = px.bar(df_melted,
                    x='Name',
                    y='Availability %',
                    color='Time Period',
                    barmode='group',
                    hover_data=['Match Score'],
                    title="Consultant Availability Over Time",
                    color_discrete_sequence=px.colors.qualitative.Set2)

        fig.update_layout(
            xaxis_title="Consultant",
            yaxis_title="Availability %",
            legend_title="Time Period",
            xaxis={'categoryorder':'total descending'}
        )

        return fig
    except Exception as e:
        st.error(f"Error creating availability chart: {e}")
        return None

def create_skills_coverage_chart(candidates, project):
    """Create a chart showing how well the top candidates cover project skills"""
    if not candidates:
        return None

    try:
        extracted_skills = project.get('ExtractedSkills', '')
        if not extracted_skills or pd.isna(extracted_skills) or not isinstance(extracted_skills, str):
            return None

        # Extract project skills
        project_skills = [s.strip() for s in extracted_skills.split(';') if s.strip()]
        if not project_skills:
            return None

        # Count skill coverage
        skill_coverage = {skill: 0 for skill in project_skills}

        for person in candidates:
            primary = person.get('PrimarySkill', "")
            secondary = person.get('SecondarySkills', [])

            for skill in project_skills:
                if (primary and skill.lower() == primary.lower()) or skill.lower() in [s.lower() for s in secondary]:
                    skill_coverage[skill] += 1

        # Create dataframe for visualization
        coverage_data = []
        for skill, count in skill_coverage.items():
            coverage_percent = (count / len(candidates)) * 100
            coverage_data.append({
                'Skill': skill,
                'Consultants with Skill': count,
                'Coverage %': coverage_percent
            })

        df = pd.DataFrame(coverage_data)

        # Create the chart
        fig = px.bar(df,
                    x='Skill',
                    y='Coverage %',
                    color='Coverage %',
                    hover_data=['Consultants with Skill'],
                    title="Project Skill Coverage by Top Candidates",
                    color_continuous_scale=px.colors.sequential.Blues)

        fig.update_layout(
            xaxis_title="Required Skill",
            yaxis_title="Coverage %",
            coloraxis_showscale=False
        )

        return fig
    except Exception as e:
        st.error(f"Error creating skills coverage chart: {e}")
        return None

def create_seniority_distribution_chart(candidates):
    """Create a pie chart showing the seniority distribution of top candidates"""
    if not candidates:
        return None

    try:
        # Count seniority levels
        seniority_counts = {}
        for person in candidates:
            seniority = person.get('Seniority', 'Unknown')
            if pd.isna(seniority) or not isinstance(seniority, str):
                seniority = 'Unknown'
            seniority_counts[seniority] = seniority_counts.get(seniority, 0) + 1

        # Create dataframe
        df = pd.DataFrame([
            {'Seniority': seniority, 'Count': count}
            for seniority, count in seniority_counts.items()
        ])

        # Create pie chart
        fig = px.pie(df,
                    values='Count',
                    names='Seniority',
                    title="Seniority Distribution of Top Candidates",
                    color_discrete_sequence=px.colors.qualitative.Set3)

        fig.update_traces(textposition='inside', textinfo='percent+label')
        fig.update_layout(margin=dict(t=30, b=10, l=10, r=10))

        return fig
    except Exception as e:
        st.error(f"Error creating seniority distribution chart: {e}")
        return None

def create_score_components_chart(candidates):
    """Create a stacked bar chart showing the score components for each candidate"""
    if not candidates:
        return None

    try:
        component_data = []
        for person in candidates:
            scores = person.get('ComponentScores', {})

            component_data.append({
                'Name': person.get('Name', ''),
                'Skills': scores.get('skills', 0) * 50,  # Scale by weight
                'Availability': scores.get('availability', 0) * 25,
                'Seniority': scores.get('seniority', 0) * 15,
                'Text Match': scores.get('text_match', 0) * 10,
                'Total Score': person.get('MatchScore', 0)
            })

        df = pd.DataFrame(component_data)
        df = df.sort_values('Total Score', ascending=False)

        # Melt the dataframe for stacked bars
        df_melted = df.melt(
            id_vars=['Name', 'Total Score'],
            value_vars=['Skills', 'Availability', 'Seniority', 'Text Match'],
            var_name='Component',
            value_name='Contribution'
        )

        # Create the chart
        fig = px.bar(df_melted,
                    x='Name',
                    y='Contribution',
                    color='Component',
                    hover_data=['Total Score'],
                    title="Match Score Breakdown by Component",
                    color_discrete_sequence=px.colors.qualitative.Bold)

        fig.update_layout(
            xaxis_title="Consultant",
            yaxis_title="Score Contribution",
            legend_title="Score Component",
            barmode='stack'
        )

        return fig
    except Exception as e:
        st.error(f"Error creating score components chart: {e}")
        return None

def create_diversity_highlight(candidates):
    """Create a chart highlighting diversity candidates"""
    if not candidates:
        return None

    try:
        # Filter for diversity candidates
        diversity_candidates = [c for c in candidates if c.get('DiversityGroup', '')]
        if not diversity_candidates:
            return None

        # Create dataframe
        df = pd.DataFrame([
            {
                'Name': person.get('Name', ''),
                'Match Score': person.get('MatchScore', 0),
                'Diversity Group': person.get('DiversityGroup', ''),
                'Seniority': person.get('Seniority', '')
            }
            for person in diversity_candidates
        ])

        # Create the chart
        fig = px.bar(df,
                    x='Name',
                    y='Match Score',
                    color='Diversity Group',
                    hover_data=['Seniority'],
                    title="Diversity & Inclusion Candidates",
                    color_discrete_sequence=px.colors.qualitative.Pastel)

        fig.update_layout(
            xaxis_title="Consultant",
            yaxis_title="Match Score",
            legend_title="Diversity Group"
        )

        return fig
    except Exception as e:
        st.error(f"Error creating diversity highlight chart: {e}")
        return None

# --- Sidebar Controls ---
st.sidebar.header("🔧 Controls")

# Project selection
st.sidebar.subheader("Project Selection")
project_ids = sorted(projects['Project ID'].unique().tolist())
project_names = [projects[projects['Project ID'] == id]['Project Name'].values[0] if len(projects[projects['Project ID'] == id]) > 0 else f"Project {id}" for id in project_ids]
project_options = [f"{id} - {name[:30]}..." if len(str(name)) > 30 else f"{id} - {name}"
                   for id, name in zip(project_ids, project_names)]

if not project_options:
    st.error("No projects found in the dataset.")
    st.stop()

selected_project_option = st.sidebar.selectbox("Select Project:", project_options)
project_id_input = int(selected_project_option.split(" - ")[0])

# Matching parameters
st.sidebar.subheader("Matching Parameters")
top_n_slider = st.sidebar.slider("Number of Candidates", min_value=3, max_value=20, value=10)

# Weight configuration
st.sidebar.subheader("Scoring Weights")
weight_skill = st.sidebar.slider("Skills Weight", min_value=0.1, max_value=0.8, value=0.5, step=0.1)
weight_avail = st.sidebar.slider("Availability Weight", min_value=0.1, max_value=0.6, value=0.25, step=0.1)
weight_senior = st.sidebar.slider("Seniority Weight", min_value=0.0, max_value=0.5, value=0.15, step=0.1)
weight_text = st.sidebar.slider("Text Match Weight", min_value=0.0, max_value=0.3, value=0.1, step=0.1)

# Normalize weights to sum to 1
total_weight = weight_skill + weight_avail + weight_senior + weight_text
weights = {
    "skills": weight_skill / total_weight,
    "availability": weight_avail / total_weight,
    "seniority": weight_senior / total_weight,
    "text_match": weight_text / total_weight
}

# Display weight percentages
st.sidebar.markdown(f"**Normalized Weights:**")
st.sidebar.markdown(f"- Skills: {weights['skills']:.1%}")
st.sidebar.markdown(f"- Availability: {weights['availability']:.1%}")
st.sidebar.markdown(f"- Seniority: {weights['seniority']:.1%}")
st.sidebar.markdown(f"- Text Match: {weights['text_match']:.1%}")

# Run matching button
run_matching = st.sidebar.button("🔄 Run Matching", type="primary")

# Initialize session state if needed
if 'candidates' not in st.session_state:
    st.session_state.candidates = []
    st.session_state.selected_project = {}

# --- Run Matching Logic ---
# Use a try-except block to catch any errors
try:
    if run_matching or not st.session_state.candidates:
        with st.spinner("Matching consultants to project..."):
            candidates, selected_project = match_candidates(project_id_input, top_n_slider, weights)
            st.session_state.candidates = candidates
            st.session_state.selected_project = selected_project

    # Use cached results if available
    candidates = st.session_state.candidates
    selected_project = st.session_state.selected_project

    # Check if matching succeeded
    if not candidates or not selected_project:
        st.warning("No matching candidates found for this project. Try adjusting the matching parameters.")
except Exception as e:
    st.error(f"An error occurred during matching: {e}")
    st.warning("Using default empty values for demonstration purposes.")
    candidates = []
    selected_project = {}

# --- Project Overview Card ---
st.markdown('<div class="sub-header">📁 Project Overview</div>', unsafe_allow_html=True)
with st.container():
    col1, col2, col3 = st.columns([1, 1, 1])

    with col1:
        st.markdown('<div class="card">', unsafe_allow_html=True)
        st.markdown(f"**Project Name:** {selected_project.get('Project Name', 'N/A')}")
        st.markdown(f"**Client:** {selected_project.get('Client Name', 'N/A')}")
        st.markdown(f"**ID:** {selected_project.get('Project ID', 'N/A')}")
        st.markdown(f"**Risk Level:** {selected_project.get('Risk Level', 'N/A')}")
        st.markdown("</div>", unsafe_allow_html=True)

    with col2:
        st.markdown('<div class="card">', unsafe_allow_html=True)
        st.markdown(f"**Start Date:** {selected_project.get('Start Date', 'N/A')}")
        st.markdown(f"**End Date:** {selected_project.get('End Date', 'N/A')}")
        st.markdown(f"**Duration:** {selected_project.get('Expected Project Duration (months)', 'N/A')} months")
        st.markdown(f"**Resources Needed:** {selected_project.get('No. of Resources', 'N/A')}")
        st.markdown("</div>", unsafe_allow_html=True)

    with col3:
        st.markdown('<div class="card">', unsafe_allow_html=True)
        budget = selected_project.get('Budget', 0)
        # Handle different formats or missing budget
        if not isinstance(budget, (int, float)):
            try:
                budget = float(budget)
            except (ValueError, TypeError):
                budget = 0

        st.markdown(f"**Budget:** £{budget:,}")

        # Extract required skills
        extracted_skills = selected_project.get('ExtractedSkills', '')
        if extracted_skills and isinstance(extracted_skills, str):
            skills = [s.strip() for s in extracted_skills.split(';') if s.strip()]
            if skills:
                st.markdown("**Key Skills Required:**")
                for skill in skills:
                    st.markdown(f"- {skill}")
        st.markdown("</div>", unsafe_allow_html=True)

# Project description
project_desc = selected_project.get('ProjectDescription', '')
if project_desc and isinstance(project_desc, str):
    with st.expander("📝 Project Description"):
        st.markdown(project_desc)

# --- Dashboard Content ---
st.markdown('<div class="sub-header">👥 Matching Results</div>', unsafe_allow_html=True)

# Top metrics
col1, col2, col3, col4 = st.columns(4)

with col1:
    st.markdown('<div class="metric-card">', unsafe_allow_html=True)
    st.markdown(f'<div class="metric-value">{len(candidates)}</div>', unsafe_allow_html=True)
    st.markdown('<div class="metric-label">Matching Consultants</div>', unsafe_allow_html=True)
    st.markdown('</div>', unsafe_allow_html=True)

with col2:
    st.markdown('<div class="metric-card">', unsafe_allow_html=True)
    top_score = max([c.get('MatchScore', 0) for c in candidates]) if candidates else 0
    st.markdown(f'<div class="metric-value">{top_score}%</div>', unsafe_allow_html=True)
    st.markdown('<div class="metric-label">Top Match Score</div>', unsafe_allow_html=True)
    st.markdown('</div>', unsafe_allow_html=True)

with col3:
    st.markdown('<div class="metric-card">', unsafe_allow_html=True)
    avg_score = np.mean([c.get('MatchScore', 0) for c in candidates]) if candidates else 0
    st.markdown(f'<div class="metric-value">{avg_score:.1f}%</div>', unsafe_allow_html=True)
    st.markdown('<div class="metric-label">Average Match Score</div>', unsafe_allow_html=True)
    st.markdown('</div>', unsafe_allow_html=True)

with col4:
    st.markdown('<div class="metric-card">', unsafe_allow_html=True)
    diversity_count = len([c for c in candidates if c.get('DiversityGroup', '')]) if candidates else 0
    st.markdown(f'<div class="metric-value">{diversity_count}</div>', unsafe_allow_html=True)
    st.markdown('<div class="metric-label">Diversity Candidates</div>', unsafe_allow_html=True)
    st.markdown('</div>', unsafe_allow_html=True)

# Check if we have candidates to display
if not candidates:
    st.warning("No matching candidates found for this project. Try adjusting your search criteria.")
else:
    # Visualization section with tabs
    tabs = st.tabs(["Match Score Analysis", "Skill Coverage", "Availability", "Consultant Details"])

    with tabs[0]:
        # Score components chart
        score_components_fig = create_score_components_chart(candidates)
        if score_components_fig:
            st.plotly_chart(score_components_fig, use_container_width=True)

        # Side by side charts
        col1, col2 = st.columns(2)

        with col1:
            # Seniority distribution
            seniority_fig = create_seniority_distribution_chart(candidates)
            if seniority_fig:
                st.plotly_chart(seniority_fig, use_container_width=True)

        with col2:
            # Diversity candidates highlight
            diversity_fig = create_diversity_highlight(candidates)
            if diversity_fig:
                st.plotly_chart(diversity_fig, use_container_width=True)
            else:
                st.info("No diversity candidates found in the top matches.")

    with tabs[1]:
        # Skill coverage chart
        skills_coverage_fig = create_skills_coverage_chart(candidates, selected_project)
        if skills_coverage_fig:
            st.plotly_chart(skills_coverage_fig, use_container_width=True)
        else:
            st.info("No skill coverage data available for this project.")

        # Primary skills distribution pie chart
        col1, col2 = st.columns(2)

        with col1:
            # Group primary skills
            primary_skills = [c.get('PrimarySkill', '') for c in candidates if c.get('PrimarySkill', '')]
            if primary_skills:
                skill_counts = pd.Series(primary_skills).value_counts()

                fig = px.pie(
                    names=skill_counts.index,
                    values=skill_counts.values,
                    title="Primary Skills of Top Candidates",
                    color_discrete_sequence=px.colors.qualitative.Pastel
                )
                fig.update_traces(textposition='inside', textinfo='percent+label')
                st.plotly_chart(fig, use_container_width=True)
            else:
                st.info("No primary skills data available.")

        with col2:
            # Create word cloud-like representation of secondary skills
            all_secondary = []
            for c in candidates:
                secondary = c.get('SecondarySkills', [])
                if isinstance(secondary, list):
                    all_secondary.extend(secondary)

            if all_secondary:
                secondary_counts = pd.Series(all_secondary).value_counts().head(10)

                if not secondary_counts.empty:
                    fig = px.bar(
                        x=secondary_counts.index,
                        y=secondary_counts.values,
                        title="Top 10 Secondary Skills",
                        labels={'x': 'Skill', 'y': 'Count'},
                        color=secondary_counts.values,
                        color_continuous_scale=px.colors.sequential.Viridis
                    )
                    st.plotly_chart(fig, use_container_width=True)
                else:
                    st.info("No secondary skills data available.")
            else:
                st.info("No secondary skills data available.")

    with tabs[2]:
        # Availability chart
        availability_fig = create_availability_chart(candidates)
        if availability_fig:
            st.plotly_chart(availability_fig, use_container_width=True)
        else:
            st.info("No availability data to display.")

        # Availability heatmap
        st.subheader("Consultant Availability Heatmap")

        # Prepare data for heatmap
        avail_data = []
        for i, person in enumerate(candidates[:8]):  # Limit to top 8 for visibility
            emp_id = person.get('EmployeeID', '')
            if not emp_id:
                continue

            emp_rows = employees[employees['EmployeeID'] == emp_id]
            if emp_rows.empty:
                continue

            emp_data = emp_rows.iloc[0]

            # Get availability for different time periods
            avail_data.append({
                'Consultant': person.get('Name', f'Consultant {i}'),
                'Next Month': emp_data.get('Available_1_month', 0),
                '3 Months': emp_data.get('Available_3_months', 0),
                '6 Months': emp_data.get('Available_6_months', 0),
            })

        if avail_data:
            # Create dataframe and melt for heatmap
            avail_df = pd.DataFrame(avail_data)
            avail_df_melted = avail_df.melt(
                id_vars=['Consultant'],
                value_vars=['Next Month', '3 Months', '6 Months'],
                var_name='Time Period',
                value_name='Availability %'
            )

            # Create heatmap
            fig = px.density_heatmap(
                avail_df_melted,
                x='Time Period',
                y='Consultant',
                z='Availability %',
                title="Availability Heatmap",
                color_continuous_scale="YlGnBu"
            )

            st.plotly_chart(fig, use_container_width=True)
        else:
            st.info("No availability data for heatmap visualization.")

        # Show allocation calendar for top 3 candidates
        st.subheader("Allocation Timeline for Top Candidates")

        # Create Gantt chart for allocations
        current_allocations = []
        for i, person in enumerate(candidates[:3]):  # Top 3 only
            emp_id = person.get('EmployeeID', '')
            if not emp_id:
                continue

            emp_allocations = allocations[allocations['EmployeeID'] == emp_id]

            for _, alloc in emp_allocations.iterrows():
                # Handle date parsing
                try:
                    start_date = pd.to_datetime(alloc['AllocationStart'])
                    end_date = pd.to_datetime(alloc['AllocationEnd'])
                except (ValueError, pd.errors.ParserError):
                    continue

                # Add to chart data
                current_allocations.append({
                    'Consultant': person.get('Name', f'Consultant {i}'),
                    'Project': f"{alloc['ProjectID']} ({alloc['AllocationPercent']}%)",
                    'Start': start_date,
                    'End': end_date,
                    'Percent': alloc['AllocationPercent']
                })

        if current_allocations:
            alloc_df = pd.DataFrame(current_allocations)

            fig = px.timeline(
                alloc_df,
                x_start="Start",
                x_end="End",
                y="Consultant",
                color="Percent",
                hover_name="Project",
                color_continuous_scale="RdYlGn_r"  # Reversed so high allocation is red
            )

            fig.update_yaxes(autorange="reversed")
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.info("No allocation data available for the top candidates.")

    with tabs[3]:
        # Individual consultant cards with detailed information
        st.subheader("Detailed Consultant Profiles")

        for i, person in enumerate(candidates):
            name = person.get('Name', f'Consultant {i}')
            title = person.get('Title', 'N/A')
            location = person.get('Location', 'N/A')
            match_score = person.get('MatchScore', 0)

            with st.expander(f"{name} ({title} | {location}) — 💡 {match_score}% Match"):
                col1, col2 = st.columns([1, 1])

                with col1:
                    st.markdown(f"**Seniority:** {person.get('Seniority', 'N/A')}")
                    st.markdown(f"**Primary Skill:** {person.get('PrimarySkill', 'N/A')}")

                    secondary_skills = person.get('SecondarySkills', [])
                    if secondary_skills and isinstance(secondary_skills, list):
                        st.markdown(f"**Secondary Skills:**")
                        skills_list = ", ".join(secondary_skills[:5])
                        if len(secondary_skills) > 5:
                            skills_list += f" and {len(secondary_skills) - 5} more"
                        st.markdown(f"{skills_list}")

                    st.markdown(f"**Availability:** {person.get('AvailableCapacity', 0):.1f}%")

                    diversity_group = person.get('DiversityGroup', '')
                    if diversity_group:
                        st.markdown(f"**Diversity Group:** {diversity_group}")

                    # Skill summary
                    skill_summary = person.get('SkillSummary', '')
                    if skill_summary:
                        with st.expander("Skill Summary"):
                            st.markdown(skill_summary)

                with col2:
                    # Radar chart for score components
                    st.markdown("**Match Score Components:**")
                    radar_fig = create_radar_chart(person)
                    if radar_fig:
                        st.plotly_chart(radar_fig, use_container_width=True)

                    # Match explanation
                    st.markdown("**Why matched?**")
                    for reason in person.get('Explanation', []):
                        st.markdown(f"- {reason}")

                # Notes field
                emp_id = person.get('EmployeeID', f'emp_{i}')
                st.text_area(f"Notes for {name}", key=f"notes_{emp_id}")

                # Action buttons
                col1, col2, col3 = st.columns([1, 1, 1])
                with col1:
                    st.button("✅ Select for Project", key=f"select_{emp_id}")
                with col2:
                    st.button("📞 Schedule Interview", key=f"interview_{emp_id}")
                with col3:
                    st.button("📝 Request More Info", key=f"info_{emp_id}")

# Footer with extra information
st.markdown("---")
st.markdown("*This dashboard uses a multi-factor matching algorithm that considers skills, availability, seniority, and text similarity to find the best consultant matches for projects.*")
st.markdown("*Data last updated: {}*".format(datetime.now().strftime("%Y-%m-%d")))

# Add export functionality
if candidates:
    candidate_df = pd.DataFrame([
        {
            "Name": c.get('Name', ''),
            "Title": c.get('Title', ''),
            "Match Score": c.get('MatchScore', 0),
            "Primary Skill": c.get('PrimarySkill', ''),
            "Availability": c.get('AvailableCapacity', 0),
            "Location": c.get('Location', ''),
            "Seniority": c.get('Seniority', '')
        }
        for c in candidates
    ])

    if st.download_button(
        "📊 Export Matching Results to CSV",
        data=candidate_df.to_csv(index=False).encode('utf-8'),
        file_name=f"project_{project_id_input}_matches.csv",
        mime="text/csv"
    ):
        st.success("Results exported successfully!")
